{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/Node/images/start.png","PathfindingVisualizer/Node/images/weight.png","PathfindingVisualizer/Node/images/wall.png","PathfindingVisualizer/Node/images/visitedWeight.png","PathfindingVisualizer/Node/images/pathWeight.png","PathfindingVisualizer/Tutorial/Tutorial.jsx","PathfindingVisualizer/Node/images/end.png","graphAlgorithm/Bfs.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","row","col","isStart","isFinish","isWall","isWeight","onMouseDown","onMouseEnter","onMouseUp","chooseWhichClass_toApply","id","className","Component","Tutorial","document","addEventListener","name","chunks","cookie","split","i","length","trim","getCookie","showPopUp","console","log","value","escape","setCookie","skipPopUp","onClick","htmlFor","src","start","alt","wall","weight","visitedWeight","pathWeight","elem","querySelector","pathfindingVisualizer","style","display","filter","bfs","grid","startNode","endNode","VisitedNodesInOrder","distance","UnVisitedNodes","nodes","node","push","getAllNodes","SortNodesByDistance","closeNode","shift","Infinity","isVisited","Update_unvisted_neighbour","sort","nodeA","nodeB","curr_node","un_visited_neighbour","nbr","getUnVisNbr","previous_node","Start_Node_Row","Start_Node_Col","Final_Node_Row","Final_Node_Col","PathfindingVisualizer","weightChangeHandler","setState","getElementById","pointChangeHandler","isvalid","parseInt","toggle_true_false","temp","changeweight","mouseIspressed","algoName","distactTobetraveled","getNewGrid","newgrid","CreatenewGridwith_Enlargepic","CreatenewGridwithWall_weight","CreatenewGridwithWall","EndNode","Order_of_Visisted_nodes","shortest_path","endnode","nodes_in_shortest_path","curr_Node","unshift","get_The_shortest_path","AnimateBfs","setTimeout","animateShortestPath","play_btn","VisulaizerBfs","changeText","ControlBox","type","min","max","onChange","defaultValue","row_max_len","col_max_len","map","rowidx","nodeidx","WhenMouseDown","WhenMouseEntre","WhenMouseUp","currRow","createNode","newNode","isBig","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.0fdea7bf.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    // onClick is equal to onMouseUp + onMouseDown\r\n    render() {\r\n        //we use className insted of class in react js\r\n        const {\r\n            row,\r\n            col,\r\n            isStart,\r\n            isFinish,\r\n            isWall,\r\n            isWeight,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n        } = this.props;\r\n        // console.log(row,col,'hi');\r\n\r\n\r\n        const chooseWhichClass_toApply = isFinish ? \"node-finish\" : isStart ? \"node-start\" : isWall ? \"node-wall\" : isWeight ? \"node-weight\" : \"\";\r\n\r\n        return (\r\n            <td\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${chooseWhichClass_toApply}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}\r\n\r\n            >\r\n\r\n            </td>\r\n        );\r\n    }\r\n\r\n}","export default __webpack_public_path__ + \"static/media/start.15955a0f.png\";","export default __webpack_public_path__ + \"static/media/weight.a219e90f.png\";","export default __webpack_public_path__ + \"static/media/wall.82e6868b.png\";","export default __webpack_public_path__ + \"static/media/visitedWeight.9d7db1f9.png\";","export default __webpack_public_path__ + \"static/media/pathWeight.1f3dc73a.png\";","import React, { Component } from \"react\";\r\n\r\nimport start from '../Node/images/start.png'; // Tell webpack this JS file uses this image\r\nimport end from '../Node/images/end.png';\r\nimport weight from '../Node/images/weight.png';\r\nimport wall from '../Node/images/wall.png';\r\nimport visitedWeight from '../Node/images/visitedWeight.png';\r\nimport pathWeight from '../Node/images/pathWeight.png';\r\n\r\n\r\nimport \"./Tutorial.css\";\r\n\r\nexport class Tutorial extends Component {\r\n\r\n    componentDidMount() {\r\n        document.addEventListener(\"DOMContentLoaded\", function () {\r\n            if (getCookie('visited') == null) {\r\n                showPopUp();\r\n                console.log(\"h\")\r\n                setCookie('visited', true);\r\n            }\r\n            else {\r\n                skipPopUp();\r\n            }\r\n        });\r\n    }\r\n    render() {\r\n        return (\r\n            <div className=\"PopUpTextBox\">\r\n                <header>\r\n                    <p>Tutorial for Dijkstra Search Visualizer</p>\r\n                    <h3 onClick={skipPopUp}>x</h3>\r\n                </header>\r\n\r\n                <div className=\"PopUpIntroductionText\">\r\n\r\n                    <div className=\"player\">\r\n\r\n                        <label htmlFor=\"start\">Start : </label>\r\n                        <img src={start} name=\"start\" alt=\"\" />\r\n\r\n                        <label htmlFor=\"end\">End : </label>\r\n                        <img src={end} name=\"end\" alt=\"\" />\r\n\r\n                        <label htmlFor=\"wall\">Wall : </label>\r\n                        <img src={wall} name=\"wall\" alt=\"\" />\r\n\r\n                        {/* <label htmlFor=\"wall\">Visited Node : </label>\r\n                        <div style={{ backgroundColor: 'rgba(0, 190, 218, 0.75)' }} name=\"wall\"></div> */}\r\n\r\n                        <label htmlFor=\"weight\">Traffic : </label>\r\n                        <img src={weight} name=\"weight\" alt=\"\" />\r\n\r\n                        <label htmlFor=\"visitedWeight\">Visited Traffic : </label>\r\n                        <img src={visitedWeight} name=\"visitedWeight\" alt=\"\" />\r\n\r\n                        <label htmlFor=\"pathWeight\">Traffic Path : </label>\r\n                        <img src={pathWeight} name=\"pathWeight\" alt=\"\" />\r\n\r\n                    </div>\r\n                    <div>\r\n\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"skipBox\">\r\n\r\n                    <button onClick={skipPopUp}>Close</button>\r\n                </div>\r\n\r\n\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport const skipPopUp = () => {\r\n    const elem = document.querySelector(\".PopUp\");\r\n    const pathfindingVisualizer = document.querySelector(\".pathfindingVisualizer\");\r\n    elem.style.display = \"none\";\r\n    pathfindingVisualizer.style.filter = \"none\";\r\n};\r\n\r\nexport const showPopUp = () => {\r\n    const elem = document.querySelector(\".PopUp\");\r\n    const pathfindingVisualizer = document.querySelector(\".pathfindingVisualizer\");\r\n    elem.style.display = \"block\";\r\n    pathfindingVisualizer.style.filter = \" blur(4px)\";\r\n};\r\n\r\n///////////////////////////////////////////////////////////////////\r\nfunction setCookie(name, value) {\r\n    var cookie = name + \"=\" + escape(value) + \";\";\r\n    document.cookie = cookie;\r\n}\r\n\r\nfunction getCookie(name) {\r\n    var chunks = document.cookie.split(\";\");\r\n    for (var i = chunks.length; i--;) {\r\n        if (chunks[i].trim().split(\"=\")[0].trim() === name) {\r\n            return chunks[i].trim().split(\"=\")[1].trim();\r\n        }\r\n    }\r\n    return null;\r\n}","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQMAAADCCAMAAAB6zFdcAAABdFBMVEX//f5tfoXz8vC6npK95/FrOSl7xmP/////bUvk3tyvk4a9opZpNSS/6/Vkd36dc2NAUF+wnpN6RzWEb2mEWkyMlJyOmZrg3tk8UFyakpBPXmuosbPMztJxg4oKAQa+vbotKitkcXdhNidkLhzQvrXs5eN8UEL+TiK1mY9QFgBOVlyLiYj+hmyLY1WMfHX/Yz331cyEXleKamFlLBhtPzFUJRJlJwyef3OsvL9kIwCeoqO21t50xFqjhXhdNinArKYyRVfQxcOwx892TkaRhoJlMCj/5mJEAADr9uWe1YyHy3LC5LbqfmT/dlTweVz9lXw1R1PX298iOUqoo6CSY1KeeUDx1l6sikTEt7Ooko1/b219UTDGp1BTIgx9Y1tyVUvU68yrppDS2sdsTjJ4uFx4RT6Uo3OAj1ft9umprIVnWzq03KeAvHGGpox8um274K9RCwA2AAD85ODVSijYhnH+QwDXfmfPjn1FOjj+tKT8o435w7dHv1e3AAAKjUlEQVR4nO2dj0PTSBbHS0IZmqSlQGjKr6tQkisHBSmBurWsxSIqri66e7vinYind+cu7rrLuue6+8/fmyRN88vORI9kOOYrYniQyZtP33vzpqE1k+Hi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4rr4Qmk7kLpQZjZtF9IWygw9mr/ckQAIOuXOpYaAECAolg8vMQRAcFgsXmoIGEG5XMQYLisEnAg4CFplgHA5a4IdBeVyRa8AiEsJwUmEYkXTbAj/H+mAYslKBIzAhmDVhFhKe7qRmosjWBTh0a9oOSwbQmc+1ghpTzdC6OFCgV44+jECm4GmWRCK5RgjFB6yFwlotjBErRlAUC5WdBuBHQnYMkM/RGGWQQZTMRCUnVqQy3kg4ECIAWGKPQYCfRjMFEFlH4IcLozAJUYkFATWIKA5agYzVupXvATcdIgBoTDHHINWLAT+ROgXxjjp0GKNQWaeGgEOebcc6liedIgRCfOM9QhIp0wFqxy6iaDPlRZmFkpzWr9PoI8E1lZHdI2Ogb8c6qUO3jMcHpa8fQJtJBQqjDGgWxmdcmgngqZPHRZtdaZ0NxLo06HEFgOBDoG/L6hYWwYbQuVj+oS0Z+0TekiTClYi9BHohbKDACa9oDvZEKNPYKsgUDXK/nII8+0FgYXB2zbjrykgsNUu05SDUHeoeRAUD107FMYiZWFkql2maJSd1qi/TQIG/UAoH/r3DnSFsSCkPfG+KBrlXiJ4pqrNeOJgxts20hZGltpl1CIxiNwmlTougk7pYzZQBZbaZVKjHLlN0rQZJxvKEAb+79GmAzMMiI1yD4HmR6DNFe0m6bA4pwX5UKVDQWcFAqlRxs8a+cuhO9P5DtZKaBNJGQnstMuElbHXHYammdNyulapVDQ9ggFdYWRndRwYBlHl0JsQ+G/U96gKYyHtqTsa3Cg7i6IeRYAgikhgpF1GAxtl304xruzCOCgSWGmXB5WDYCJA5LsT9HzVP/ZZNTKE+bRnD/OvlGfSVjnlxQFVrHtmdq9TLoYP8Yd3fxhXnu115EXwLeu0GVx7BOu7dRPdUrHsObS+sObxCbI59EYLXuXwsNN5lHJNQAK+/fnVZFr6Cl8+9WYR3wZfGktLS6zchk+VQdqTd4SWvk4JwdfsMIAm8IaUvGRoJVlhgIvCkpi8lpioBK5SYpD2tH3CDGQ62f5/+FuUw8hMMqirIdWjbHiekhElCVNohM+JHqbGHoOaMT0blNoImfYMi4GiZINSFAnHgbEXOqe+ETJNT9RYjIOJ2XxQG2sh0yxmIEphBADBZtAKndOYDJmuMctgOCBgELBQMQieAwyCJs6AM+AMOAPOgDPgDDgDzoAzuFgMLv1+wVibDkqth0xrRAaT4WE2IoZhkoE6EZJhhG0qgYEaPidqGDYZTMwGywHUg5CJIhdC5zQmQyZGc4HXxE9jcAt/XG4Gt/76zf63ty4yA+uWoywatGujLIcYfLO/vz8BDGRZpl0bRXmJkXuNIPT46OioWa+bkytBdZ+FTE/Mer0RYgAI9v+mSHIDhjkOD9ONHgau+5gNCGjt9tMt0OLW8vLylvXp6fLyU/xpcTFk2vocfjLE4Nv9/b9DLsjmFny/d4p73mLYBFcDLd9uMMJg90azqjYbZnWvVcoq062VarfVerJ53GqBqQSmEpiMUskyPVPqjWa4JpoTuCbKzYZRfQLnKSutkmKWSnubz1qt42q3BEOtlFbA1FqzTIrZaJrVoxu7jGQDQje2x2TR3L6WzyvKcP7m9nE+3/psJZ/vgmnYrF7PX99WoRRg0+RmM1wP3LVRluub0/m8sYlPMfEpUFH2Nhtg2gbTZhcqwWeT2ARlxdjUGSEAAgYNh0FVuQ4MNjCDvfywy+DmtjpsYwEGg/oDi8GwsXnTxwCYTlgMDFhYPAxyzCDI+OLgej8OPpZBKA4uBgN/HBxf6jjw5MInxcHN6HpwIRjYubAx7I0DJXYcdC0G1oR7DEyXwbbNoMYMA6tTcxgohqpms6raVUxVNfBXtklxTfDJrBIY9EZRlWzvFHuors9k9hik2yuizJ2Tk5M7yF4bZbXalKRsdkdqKoYkNap1STKwyeyZxhzTYAbVMThFaUo7iolPUSVJxaassuMzNWSLAUKWDym9CyNC9w7aWAdvrJoIDHZkOZutyVLVkOVm1TGJZlaSJaVvIjGA/gG2DnCKiU+py7bJrEpyTTFFMKmOCfcHPR9OUokG4W57xFb74Plm3ZqwKAIDcadqiC4DETOAOcN2kZqBiLdPkj1hDwMxxOAfB64Pd5N/rSNC7uWxXjQ+yKB2XgzEiRceD9oHSQcCQne9CEZenm8cjEUy+OdLrwvtu0lDOPEhGGn/S0w8F2r/HvH7cCdZBIEwgEBInoH4MsAg6UAIIBgZeZ50PRCfB10YSZbBqyCD9nf2QojXxp2otbEbY20UnbVRHLg2fhfy4VXaDETrQc/Cg76jGDUReiRRxBO24sAyjTmmGv79xA8wEPEj7MYBhI6KTWOQUbap1jM1ReYYjHy/tUirLfNDcSCbMUb5PuhCO9kWAR0EHXhBcPlzj7rjkhkhyJmu98cII74IunCQKIIMOg0EwusSSQNerRot4oivA2FwmvC6EEiG9g9TJMVmQBzxh4APyZYDCIR7Xgfar4kOTw3Nx9NQiTjka58P9xLfNXmzof0jRCbB39LUlT/F0RUiAbjmjx4fTlPYOUIk2B6026ePxylUiSeaIR+fuj4kHwWYARLewN6xfXB6h+6VPLFe+q5rNEMuoVenB3jP+OZVSk8mIcDwE77RQ8fAerMHetExACd2f9LSfD4NCbd3Ee0runJ6Dr/rRc5554v+oRY+hD+UDDJo93aqr/CLwaA2PRuvHhyNs83AfcNv4edd/M8u1CeCu+NDcd5AGos44vi4dfG5n4UU3oAcnT1YdfSLdXR/dHT0LYlBXBEYvFsfHb1vXfyXnjcPzpKDgK7++ueQ/kNgML8QT/ODGchvwy78miCDTOYMHgS/3g1GAPrtShz9RhzvXdCF9bMECUAkrAYdILos9pe9nNZbBQKHnh+hWBeCLqwmWxrR+0AgfEHBIEfdJdH1B18EwuB9wgyCyUBOBVGLJ/KAgWRYT7Qa4MXxftxUwD0SfNh/3APfoe45pOmR/C7cT7hZFITffYHwgOjv+MoU8UkRr6ZWyD3SA18Y/C4IST2ZBo0R1lUfg7fEl+rH7g8K48Qx3/oYXLX8SiQYBEf+VBRIonoHZh8DjTimvyj1rOdOALkOfOlNRaK7gl6Z+UsszerkQb3J8KVrPW8G/ev/0X8Q1t+T3RWE0O/bDhbNkJ6itP5H33y+CPphIJyFUpEgXdPjiGZIb1HynHDOJcHjwOp6T6Mh5yIZ0PdI+IkkqjFHXR9WPdbzReCFcHbVVWoM+i54qvJ5I/BRiKeYfeLHXiYBAvjX0T7WvQSUWKvILIWkALgg0p5wQCid31FkJh7SmLwfRJoRwdj/E5747Bmbvy3HpXOfOpOTjxD28n+XJL0RL6osGva2Ht+VIYFBQu9eCUK9T1xcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFzs67+dq3fOSykJ7QAAAABJRU5ErkJggg==\"","\r\nexport function bfs(grid, startNode, endNode) {\r\n    const VisitedNodesInOrder = [];//to animate the searching process\r\n    startNode.distance = 0;\r\n\r\n    //to get all the nodes in grid\r\n    const UnVisitedNodes = getAllNodes(grid);\r\n    // console.log(UnVisitedNodes[0], \"hi\");\r\n\r\n    while (UnVisitedNodes.length) {\r\n        SortNodesByDistance(UnVisitedNodes);\r\n        const closeNode = UnVisitedNodes.shift();//return the first element or undefined\r\n\r\n        //if there is a wall then continue\r\n        if (closeNode.isWall) continue;\r\n\r\n        //making the nodes as visited\r\n        if (closeNode.distance === Infinity) return VisitedNodesInOrder;\r\n        closeNode.isVisited = true;\r\n\r\n        VisitedNodesInOrder.push(closeNode);\r\n\r\n        if (closeNode === endNode) {\r\n            // console.log(VisitedNodesInOrder[0], \"aatoh rah ahe\");\r\n            return VisitedNodesInOrder;\r\n        }\r\n\r\n\r\n        //updating my neighbours which are close to closenode  \r\n        Update_unvisted_neighbour(closeNode, grid);\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n//sort the unvisited nodes\r\nfunction SortNodesByDistance(UnVisitedNodes) {\r\n    //as the nodes have distace(a string number)\r\n    //sort function doesnot work for string_number\r\n    //so we use compare function\r\n    UnVisitedNodes.sort(function (nodeA, nodeB) { return nodeA.distance - nodeB.distance });//in ascending order\r\n\r\n}\r\n\r\nfunction Update_unvisted_neighbour(curr_node, grid) {\r\n    const un_visited_neighbour = getUnVisNbr(curr_node, grid);\r\n\r\n    //nbr-->neighbours\r\n    for (let nbr of un_visited_neighbour) {\r\n        //setting the distance of the nbr nodes \r\n        //checking if my previous distance is greater then my curr distance\r\n        if (nbr.distance > curr_node.distance + nbr.weight) {\r\n            nbr.distance = curr_node.distance + nbr.weight;\r\n        }\r\n\r\n        // console.log(nbr.weight);\r\n        // With this property we can backtrack and find the shortest path between the start and end node.\r\n        nbr.previous_node = curr_node;\r\n    }\r\n\r\n}\r\n\r\nfunction getUnVisNbr(node, grid) {\r\n    let nbr = [];//nbr-->neighbours\r\n    const {\r\n        row, col\r\n    } = node;//col and row properties of node\r\n\r\n    if (row > 0) nbr.push(grid[row - 1][col]);\r\n    if (col > 0) nbr.push(grid[row][col - 1]);\r\n    if (row < grid.length - 1) nbr.push(grid[row + 1][col]);\r\n    if (col < grid[0].length - 1) nbr.push(grid[row][col + 1]);\r\n\r\n    return nbr.filter((i) => !i.isVisited);\r\n\r\n\r\n}\r\n\r\n\r\nfunction getAllNodes(grid) {\r\n    let nodes = [];\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//bfs\r\n\r\n// const dx = [-1, 1, 0, 0];\r\n// const dy = [0, 0, -1, 1];\r\n\r\n// function isSafe(row, col, grid) {\r\n//     let rowLength = grid.length;\r\n//     let columnLength = grid[0].length;\r\n//     if (row >= rowLength || row < 0 || col >= columnLength || col < 0 || grid[row][col].isVisited) return false;\r\n//     return true;\r\n// }\r\n\r\n\r\n\r\n// export function bfs(grid, startNode, endNode) {\r\n//     const VisitedNodesInOrder = [];\r\n//     let queue = [startNode];\r\n\r\n//     while (queue.length) {\r\n//         const curr_Node = queue.shift();\r\n//         // console.log(\"he\");\r\n\r\n\r\n//         if (!curr_Node.isWall && (curr_Node.isStart || !curr_Node.isVisited)) {\r\n//             curr_Node.isVisited = true;\r\n\r\n//             VisitedNodesInOrder.push(curr_Node);\r\n\r\n//             const { col, row } = curr_Node;\r\n\r\n//             let next_Node;\r\n\r\n//             for (let i = 0; i < 4; i++) {\r\n//                 let R = row + dx[i];\r\n//                 let C = col + dy[i];\r\n//                 // console.log(row, col);\r\n\r\n//                 if (isSafe(R, C, grid)) {\r\n//                     // console.log(R, C);\r\n//                     next_Node = grid[R][C];\r\n//                     // console.log(next_Node);\r\n//                     // if (next_Node.row == 19 && next_Node.col == 48) {\r\n//                     //     console.log(\"19-48\");\r\n//                     // }\r\n//                     // else if (next_Node.row == 18 && next_Node.col == 49) {\r\n//                     //     console.log(\"19-49\");\r\n//                     // }\r\n//                     next_Node.previous_node = curr_Node;\r\n//                     queue.push(next_Node);\r\n\r\n//                 }\r\n//             }\r\n//         }\r\n//         if (curr_Node == endNode) return VisitedNodesInOrder;\r\n\r\n//     }\r\n//     return VisitedNodesInOrder;\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//backtracking from end node to start node to  get the minmum path\r\nexport function get_The_shortest_path(endnode) {\r\n    let nodes_in_shortest_path = [];\r\n    let curr_Node = endnode;\r\n    while (curr_Node !== null) {\r\n        nodes_in_shortest_path.unshift(curr_Node);\r\n        curr_Node = curr_Node.previous_node;\r\n    }\r\n    return nodes_in_shortest_path;\r\n}\r\n\r\n\r\n\r\n// const depthFirstSearch = (grid, startNode, finishNode) => {\r\n//     const dx = [-1, 0, 1, 0];\r\n//     const dy = [0, 1, 0, -1];\r\n\r\n//     const visitedNodesInOrder = [];\r\n//     const dfsStack = [];\r\n\r\n//     dfsStack.push(startNode);\r\n//     while (dfsStack.length) {\r\n//       const currentNode = dfsStack.pop();\r\n\r\n//       if (currentNode === finishNode) {\r\n//         return visitedNodesInOrder;\r\n//       }\r\n\r\n//       if (!currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)) {\r\n//         currentNode.isVisited = true;\r\n//         visitedNodesInOrder.push(currentNode);\r\n//         const { col, row } = currentNode;\r\n//         let nextNode;\r\n\r\n//         for(let i = 0 ; i < 4 ; ++i) {\r\n//           if(isValid(row + dx[i] , col + dy[i])) {\r\n//             nextNode = grid[row + dx[i]][col + dy[i]];\r\n//             if(!nextNode.isVisited) {\r\n//               nextNode.previousNode = currentNode;\r\n//               dfsStack.push(nextNode);          \r\n//             }\r\n//           }\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return visitedNodesInOrder;\r\n//   }\r\n\r\n\r\n//   const dfsBtn = document.getElementById('dfs');\r\n//   dfsBtn.addEventListener('click', async () => {\r\n//     const startNode = grid[startRow][startCol];\r\n//     const finishNode = grid[finishRow][finishCol];\r\n\r\n//     clearGrid();\r\n//     isRunning = true;\r\n\r\n//     toggledButtonDisable(isRunning);\r\n\r\n//     const visitedeNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\r\n\r\n\r\n\r\n//     await animateAlgorithm(visitedeNodesInOrder, \"dfs\");\r\n//     const path = getPath(finishNode);\r\n\r\n//     await animatePath(path);\r\n//     isRunning = false;\r\n\r\n//     toggledButtonDisable(isRunning);\r\n\r\n//   })","import { render } from '@testing-library/react';\r\nimport React, { Component } from 'react';\r\n\r\nimport Node from './Node/Node.jsx';\r\nimport { showPopUp } from \"./Tutorial/Tutorial.jsx\";\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nimport { bfs, get_The_shortest_path } from \"../graphAlgorithm/Bfs\";\r\n\r\nlet row_max_len = 20;\r\nlet col_max_len = 50;\r\n\r\nlet Start_Node_Row = 0;\r\nlet Start_Node_Col = 0;\r\nlet Final_Node_Row = 19;\r\nlet Final_Node_Col = 49;\r\n\r\n\r\n\r\n\r\n\r\n// The component also requires a render() method, this method returns HTML.\r\nexport default class PathfindingVisualizer extends Component {\r\n\r\n    //propes are arguments that are passed into the argument \r\n    //propes -->properties\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        //state-->built in object\r\n        //the state may contain as many properties as u like\r\n        //thinks we need to update/change we put in this.state\r\n        this.state = {\r\n            grid: [],\r\n            mouseIspressed: false,\r\n            algoName: \"BREADTH FIRST ALGORITHM\",\r\n            weight: 1,\r\n            changeweight: false,\r\n            distactTobetraveled: 0\r\n\r\n        };\r\n    }\r\n\r\n    //greating a grid\r\n    // / The componentDidMount() method is called after the component is rendered\r\n    //this is where u run statement that requires that the componenet is alreadu is placed in the DOM\r\n    componentDidMount() {\r\n        const grid = getNewGrid();\r\n        this.setState({ grid });\r\n    }\r\n\r\n\r\n    // // on pressing the mouse down\r\n    // When user press the mouse button down, a mousedown event is triggered, and when user release, a mouseup event is triggered.\r\n    WhenMouseDown(row, col) {\r\n        let newgrid = [];\r\n        if (row == Start_Node_Row && col == Start_Node_Col) {\r\n            console.log(\"in\");\r\n\r\n            CreatenewGridwith_Enlargepic(this.state.grid, row, col);\r\n            this.setState({ mouseIspressed: true });\r\n            return;\r\n\r\n        }\r\n        if (this.state.changeweight) {\r\n            newgrid = CreatenewGridwithWall_weight(this.state.grid, row, col, this.state.weight);\r\n        }\r\n        else {\r\n            newgrid = CreatenewGridwithWall(this.state.grid, row, col);\r\n        }\r\n        this.setState({ grid: newgrid, mouseIspressed: true });\r\n    }\r\n\r\n    //relising the mousedown btn\r\n    WhenMouseUp() {\r\n        if (this.state.mouseIspressed) {\r\n            console.log(\"out\");\r\n            this.setState({ mouseIspressed: false });\r\n        }\r\n    }\r\n\r\n    //whenever the mouse hover over over the grid\r\n    WhenMouseEntre(row, col) {\r\n\r\n        if (!this.state.mouseIspressed) return;\r\n\r\n        let newgrid = [];\r\n        if (this.state.changeweight) {\r\n            newgrid = CreatenewGridwithWall_weight(this.state.grid, row, col, this.state.weight);\r\n        }\r\n        else {\r\n            newgrid = CreatenewGridwithWall(this.state.grid, row, col);\r\n        }\r\n        this.setState({ grid: newgrid });\r\n\r\n    }\r\n\r\n\r\n\r\n    //weightToggle\r\n    weightChangeHandler = () => {\r\n        // console.log(this.state.weight);\r\n        this.setState({ weight: document.getElementById('weight').value });\r\n\r\n        // console.log(this.state.grid[Start_Node_Row - 1][Start_Node_Col + 1]);\r\n\r\n    };\r\n\r\n\r\n    VisulaizerBfs() {\r\n        const {\r\n            grid\r\n        } = this.state;\r\n        const startNode = grid[Start_Node_Row][Start_Node_Col];\r\n        const EndNode = grid[Final_Node_Row][Final_Node_Col];\r\n        // console.log(startNode, EndNode);\r\n        const Order_of_Visisted_nodes = bfs(grid, startNode, EndNode);\r\n        // console.log(Order_of_Visisted_nodes[0], \"ko\");\r\n        const shortest_path = get_The_shortest_path(EndNode);\r\n        this.AnimateBfs(Order_of_Visisted_nodes, shortest_path);\r\n\r\n    }\r\n\r\n\r\n    AnimateBfs(Order_of_Visisted_nodes, shortest_path) {\r\n        // console.log(this.state.grid[Start_Node_Row - 1][Start_Node_Col + 1], this.state.grid[Start_Node_Row - 1][Start_Node_Col + 2]);\r\n        // console.log(this.state.grid[Start_Node_Row + 1][Start_Node_Col + 1]);\r\n        for (let i = 1; i <= Order_of_Visisted_nodes.length; i++) {\r\n\r\n            //when we reach the final node\r\n            if (i === Order_of_Visisted_nodes.length) {\r\n                setTimeout(() => {\r\n                    // this.setState({ algoName: \"Shortest Path\" });\r\n                    this.animateShortestPath(shortest_path);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n\r\n            if (i === Order_of_Visisted_nodes.length - 1) continue;\r\n            setTimeout(() => {\r\n                const node = Order_of_Visisted_nodes[i];\r\n                if (node.isWeight) {\r\n                    // The Document method getElementById() returns an Element object representing the element whose id property matches the specified string\r\n                    // let Weighted_node = document.getElementById(`node-${node.row}-${node.col}`);\r\n                    let Weighted_node = node\r\n                    Weighted_node.className = \"node node-visitedWeight\";\r\n                }\r\n                else {\r\n                    let Visited_node = document.getElementById(`node-${node.row}-${node.col}`);\r\n                    Visited_node.className = \"node node-isVisited\";\r\n                }\r\n            }, 10 * i);\r\n\r\n        }\r\n    }\r\n\r\n    animateShortestPath(shortest_path) {\r\n        let time_taken = 0;\r\n        for (let i = 1; i < shortest_path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                const node = shortest_path[i];\r\n                if (node.isWeight) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-ShortP-Weight\";\r\n                }\r\n                else {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-ShortP\";\r\n                }\r\n            }, 50 * i);\r\n        }\r\n        // console.log(this.state.grid[9][31]);\r\n        time_taken = shortest_path[shortest_path.length - 1].distance;\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    //allocate staring point and endingpoint\r\n    pointChangeHandler = () => {\r\n        if (this.isvalid()) return;\r\n        //removing the previous pics from the grid \r\n        //class named node is a clear grid with no pics \r\n        document.getElementById(`node-${Start_Node_Row}-${Start_Node_Col}`).className = \"node\";\r\n        document.getElementById(`node-${Final_Node_Row}-${Final_Node_Col}`).className = \"node\";\r\n\r\n        Start_Node_Row = parseInt(document.querySelector('#start_row').value);\r\n        Start_Node_Col = parseInt(document.querySelector('#start_col').value);\r\n        Final_Node_Row = parseInt(document.querySelector('#end_row').value);\r\n        Final_Node_Col = parseInt(document.querySelector('#end_col').value);\r\n\r\n        // let changeStart = document.getElementById(`node-${Start_Node_Row}-${Start_Node_Col}`);\r\n        document.getElementById(`node-${Start_Node_Row}-${Start_Node_Col}`).className = 'node node-start';\r\n\r\n        // let changeFinal = document.getElementById(`node-${Final_Node_Row}-${Final_Node_Col}`);\r\n        document.getElementById(`node-${Final_Node_Row}-${Final_Node_Col}`).className = 'node node-finish';\r\n\r\n\r\n    }\r\n\r\n    isvalid = () => {\r\n\r\n        // if (\r\n        //     isNaN(parseInt(document.getElementById(\"start_row\").value)) ||\r\n        //     isNaN(parseInt(document.getElementById(\"start_col\").value)) ||\r\n        //     isNaN(parseInt(document.getElementById(\"end_row\").value)) ||\r\n        //     isNaN(parseInt(document.getElementById(\"end_col\").value))\r\n        // ) return true;\r\n\r\n\r\n        if (\r\n            parseInt(document.getElementById(\"start_row\").value) > row_max_len ||\r\n            parseInt(document.getElementById(\"start_col\").value) > col_max_len\r\n        ) return true;\r\n\r\n        if (\r\n            parseInt(document.getElementById(\"start_row\").value) < 0 ||\r\n            parseInt(document.getElementById(\"start_col\").value) < 0\r\n        ) return true;\r\n\r\n\r\n        if (\r\n            parseInt(document.getElementById(\"end_row\").value) > row_max_len ||\r\n            parseInt(document.getElementById(\"end_col\").value) > col_max_len\r\n        ) return true;\r\n\r\n        if (\r\n            parseInt(document.getElementById(\"end_row\").value) < 0 ||\r\n            parseInt(document.getElementById(\"end_col\").value) < 0\r\n        ) return true;\r\n\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    toggle_true_false = () => {\r\n        // changeweight is ued to for true or false of the weight\r\n        const temp = this.state.changeweight;\r\n        this.setState({ changeweight: !temp });\r\n    };\r\n\r\n    render() {\r\n        const {\r\n            grid,\r\n            mouseIspressed,\r\n            algoName,\r\n            distactTobetraveled,\r\n        } = this.state;\r\n\r\n        let play_btn = (\r\n            <h3 className='btn' onClick={() => this.VisulaizerBfs()}>Start BFS</h3>\r\n        );\r\n\r\n        // bnt change to true or false\r\n        let changeText = \"Close\";\r\n        if (this.state.changeweight) changeText = \"Open\";\r\n\r\n        //storing into one div(ControlBox)\r\n        let ControlBox = (\r\n            <div className=\"controlbox\">\r\n                <div className=\"weightContainer\">\r\n                    <label htmlFor='quantity'>Food:</label>\r\n\r\n                    <input type=\"number\" id=\"weight\" name=\"quantity\" min=\"1\" max=\"5\" onChange={this.weightChangeHandler} defaultValue=\"1\" />\r\n\r\n                    {/* make btn true or false */}\r\n                    <button onClick={this.toggle_true_false}>{changeText}</button>\r\n                </div>\r\n\r\n                {/* //startpoint: */}\r\n                <div className=\"startPointContainer\">\r\n                    <label htmlFor=\"point\">Start Point:</label>\r\n                    {/* The onchange event occurs when the value of an element has been changed */}\r\n\r\n                    <input type=\"number\" id=\"start_row\" name=\"point\" min=\"0\" max={row_max_len - 1} onChange={this.pointChangeHandler} defaultValue=\"0\"></input>\r\n\r\n                    <input type=\"number\" id=\"start_col\" name=\"point\" min=\"0\" max={col_max_len - 1} onChange={this.pointChangeHandler} defaultValue=\"0\"></input>\r\n                </div>\r\n\r\n                {/* //endpoint: */}\r\n                <div className=\"endPointContainer\">\r\n                    <label htmlFor=\"point\">End Point:</label>\r\n                    <input type=\"number\" id=\"end_row\" name=\"point\" min=\"0\" max={row_max_len - 1} onChange={this.pointChangeHandler} defaultValue=\"19\"></input>\r\n                    <input type=\"number\" id=\"end_col\" name=\"point\" min=\"0\" max={col_max_len - 1} onChange={this.pointChangeHandler} defaultValue=\"49\"></input>\r\n                </div>\r\n\r\n                <div className=\"buttonContainer\">{play_btn}</div>\r\n\r\n\r\n            </div>\r\n\r\n\r\n\r\n        );\r\n\r\n\r\n\r\n\r\n\r\n        return (\r\n\r\n\r\n            <div className=\"pathfindingVisualizer\">\r\n                <div className=\"container\">\r\n                    <header>\r\n                        <h2 className=\"top\" onClick={showPopUp}>Pathfinding Visualizer</h2>\r\n                        <h2 className=\"algo\">{algoName}</h2>\r\n                    </header>\r\n                    {ControlBox}\r\n                    <p>Breadth first algorithm is used for finding the shortest distance, or path, from starting node to any other node in a unweighted path  </p>\r\n\r\n                </div>\r\n\r\n\r\n                {/* --------------grid dispaly----------------- */}\r\n                <div className=\"visualGridContainer\">\r\n                    <div className='gridBox'>\r\n                        <table className='grid' >\r\n                            {/* //The <tbody> tag is used to group the body content in an HTML table */}\r\n                            <tbody>\r\n                                {\r\n                                    grid.map((row, rowidx) => {\r\n                                        return (\r\n                                            /* A “key” is a special string attribute you need to include when creating lists of elements. */\r\n                                            /* Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity: */\r\n                                            <tr key={rowidx}>\r\n                                                {row.map((node, nodeidx) => {\r\n                                                    const { isStart, isFinish, isWall, isWeight } = node; //Extracting from the node\r\n                                                    // console.log(node.isStart, node.isFinish, node.isWall);\r\n                                                    return (\r\n                                                        <Node\r\n                                                            row={rowidx}\r\n                                                            col={nodeidx}\r\n                                                            key={rowidx + \"-\" + nodeidx}\r\n                                                            isStart={isStart}\r\n                                                            isFinish={isFinish}\r\n                                                            isWall={isWall}\r\n                                                            isWeight={isWeight}\r\n                                                            mouseIspressed={mouseIspressed}\r\n                                                            //attribute onMouseDown and onMouseEnterin reactjs\r\n                                                            onMouseDown={(row, col) =>\r\n                                                                this.WhenMouseDown(row, col)\r\n                                                            }\r\n                                                            onMouseEnter={(row, col) =>\r\n                                                                this.WhenMouseEntre(row, col)\r\n                                                            }\r\n                                                            onMouseUp={() => this.WhenMouseUp()}>\r\n\r\n                                                        </Node>\r\n                                                    );\r\n\r\n                                                })}\r\n                                            </tr>\r\n                                        );\r\n                                    })\r\n                                }\r\n                            </tbody>\r\n\r\n                        </table>\r\n\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n//this const function always should be defined outside of the class\r\nconst getNewGrid = () => {\r\n    const grid = [];\r\n    for (var row = 0; row < row_max_len; row++) {\r\n        const currRow = [];\r\n        for (var col = 0; col < col_max_len; col++) {\r\n            currRow.push(createNode(row, col));\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n\r\n};\r\n\r\n//const should be there before a function always\r\n//creating a grid\r\nconst createNode = (row, col) => {\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === Start_Node_Row && col === Start_Node_Col,\r\n        isFinish: row === Final_Node_Row && col === Final_Node_Col,\r\n        distance: Infinity,\r\n        isWall: false,\r\n        isWeight: false,\r\n        isVisited: false,\r\n        previous_node: null,\r\n        weight: 0,\r\n    };\r\n};\r\n\r\n\r\nconst CreatenewGridwithWall = (grid, row, col) => {\r\n\r\n    // const newGrid = [...grid];\r\n    //     // ES6 (shallow copy)\r\n    //     // For completeness, note that ES6 offers two shallow copy mechanisms: Object.assign() and the spread syntax. which copies values of all enumerable own properties from one object to another.\r\n    //     //copy from one oject to another\r\n    //     const newgrid = [...grid];\r\n    const node = grid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    grid[row][col] = newNode;\r\n    // console.log(grid[row][col - 1]);\r\n    return grid;\r\n}\r\n\r\n\r\nconst CreatenewGridwithWall_weight = (grid, row, col, weight) => {\r\n\r\n    const node = grid[row][col];\r\n    if (node.weight != 0) {\r\n        node.weight = 0;\r\n        node.isWeight = !node.isWeight;\r\n        grid[row][col] = node;\r\n        console.log(node);\r\n    }\r\n    else {\r\n        const newNode = {\r\n            ...node,\r\n            isWeight: !node.isWeight,\r\n            weight: parseInt(weight),\r\n        };\r\n        grid[row][col] = newNode;\r\n        console.log(newNode);\r\n    }\r\n\r\n\r\n    return grid;\r\n}\r\n\r\n\r\nconst CreatenewGridwith_Enlargepic = (grid, row, col, weight) => {\r\n    const node = grid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isBig: !node.isBig,\r\n    };\r\n    grid[row][col] = newNode;\r\n    // console.log(grid[row][col - 1]);\r\n    return grid;\r\n}\r\n\r\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer.jsx\";\nimport { Tutorial } from \"./PathfindingVisualizer/Tutorial/Tutorial.jsx\";\nfunction App() {\n  return (\n    <div className=\"App\">\n\n      <PathfindingVisualizer></PathfindingVisualizer>\n      <div className=\"PopUp\">\n        <Tutorial />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}